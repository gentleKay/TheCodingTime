### 填充每个节点的下一个右侧节点指针













题解：

**迭代**：C++

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if (!root)
		{
			return nullptr;
		}

		queue<Node*> queNode;
		queNode.emplace(root);

		while (!queNode.empty())
		{
			int nSize = queNode.size();

			for (int i = 0; i < nSize; i++)
			{
				Node* node = queNode.front();
				queNode.pop();

				if (i < nSize - 1)
				{
					node->next = queNode.front();
				}

				if (node->left)
				{
					queNode.emplace(node->left);
				}

				if (node->right)
				{
					queNode.emplace(node->right);
				}
			}
		}

		return root;
    }
};
```



**递归**：C++

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
		if (!root)
		{
			return nullptr;
		}
		DFS(root);
		return root;
	}

	void DFS(Node* root)
	{
		if (!root->left)
		{
			return;
		}

		root->left->next = root->right;

		if (root->next)
		{
			root->right->next = root->next->left;
		}

		DFS(root->left);
		DFS(root->right);
	}
};
```



**迭代**：C#

```c#
/*
// Definition for a Node.
public class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
}
*/

public class Solution {
    public Node Connect(Node root) {
        if (root == null)
            {
                return null;
            }

            Queue<Node> queNode = new Queue<Node>();
            queNode.Enqueue(root);

            while (queNode.Count > 0)
            {
                int nSize = queNode.Count;

                for (int i = 0; i < nSize; i++)
                {
                    Node node = queNode.Dequeue();

                    if (i < nSize - 1)
                    {
                        node.next = queNode.Peek();
                    }

                    if (node.left != null)
                    {
                        queNode.Enqueue(node.left);
                    }

                    if (node.right != null)
                    {
                        queNode.Enqueue(node.right);
                    }
                }
            }

            return root;
    }
}
```



**递归**：C#

```c#
/*
// Definition for a Node.
public class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
}
*/

public class Solution {
    public Node Connect(Node root)
    {
        if (root == null)
        {
            return null;
        }

        DFS(root);

        return root;
    }

    public void DFS(Node root)
    {
        if (root.left == null)
        {
            return;
        }

        root.left.next = root.right;

        if (root.next != null)
        {
            root.right.next = root.next.left;
        }

        DFS(root.left);
        DFS(root.right);
    }
}
```



https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/